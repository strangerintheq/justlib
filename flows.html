<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>flows</title>
</head>
<body style="overflow: hidden; margin: 0">
<script src="palettes.js"></script>
<script src="lib.js"></script>
<script>
    let pad = pick([0.01, 0.1, 0.05])
    let seed = rnd(9999)
    let ratio = 0.75;
    let scale = pick([1, 0.95,0.9,0.85])
    let colors = pick(Object.values(palettes));

    palette(colors)
    createCanvas2d(ratio)
    appendCanvas()
    let ctx = state.last;
    ctx.scale(scale, scale)
    fillStyle(0)
    fillRect(-2, -2, 4, 4)
    strokeWidth(0.001)

    bgLines()

    const tree = q3(0, 0, 0.45, 0.6)

    let z = 0;
    part(0.004, colors[rndi(4) + 1])
    z = 1
    part(0.01, colors[rndi(4) + 1])


    function bgLines() {
        let xx = .1, ll = .1
        many(10111, () => {
            strokeStyle(hslOperation(colors[0], hsl => hsl[2] += rnds(ll)))
            let i = rnds(1.5), a = i + rnds(xx), b = i + rnds(xx);
            let pts = rndb() ? [[a, -2], [b, 2]] : [[-2, a], [2, b]];
            ctx.stroke(new Path2D("M" + pts.join("L")))
        })
    }

    function check(x, y, r, maxR) {
        let n = noise(22 * x, 22 * y, seed)
        if (z === 0 && n > 0)
            return true
        if (z === 1 && n < 0)
            return true
        const candidates =
            tree.query(x, y, maxR + r);
        return candidates.find(p => {
            return hypot(p.x - x, p.y - y) < p.r + r + pad
        })
    }

    function brush(r, color, pts) {
        const randomizeLightness = hsl => hsl[2] = clamp(hsl[2] + rnds(.3), 0.1, 0.9);

        const n = sqrt(PI * pow(ctx.canvas.width * r, 2));
        many(n, () => {
            let dr = rnd(r), a = rndr();
            let cx = cos(a) * dr, cy = sin(a) * dr;
            return {x: cx, y: cy}
        }).forEach(stroke => {
            strokeStyle(hslOperation(color, randomizeLightness));
            ctx.beginPath()
            pts.forEach((pt, i) => {
                let x = stroke.x + pt.x;
                let y = stroke.y + pt.y;
                i ? ctx.lineTo(x, y) : ctx.moveTo(x, y);
            })
            ctx.stroke()
        })
    }

    function stick(r, color, pts) {

    }

    function part(maxR, color) {

        const turnChance = pick([0.9, 0.99, 1])
        const centers = many(pick([3,0,1,2]), () => [rnds(), rnds()])
        const nk = pick([0,1])
        const angle = pick([0,1,2])
        const flowFieldFunction = (x, y) => {
            const c = centers.map(p => 1 + atan2(p[1] - y, p[0] - x))
                .reduce((a, b) => a + b, 0)
            const n = noise(seed + 5 * x, 5 * y, seed)*nk
            return {a: n + c+ angle};
        };

        const ffd = field(333, flowFieldFunction, 0, 0, 0.4, 0.4 / ratio);

        const lines = []

        many(9999, singleThing)

        lines.forEach(line => {
            brush(line[0].r, color, line)
        })

        function singleThing() {
            let pts = []
            let x = rnds()
            let y = rnds(1 / ratio)
            let da = 0;
            let r = rnd(maxR * 0.9, maxR * 0.1)
            let i = 0
            while (i++ < 133 && !check(x, y, r, maxR)) {
                pts.push({x, y, r})
                let cell = ffd(x, y)
                if (!cell)
                    break
                if (rndb(turnChance))
                    da += pick([-1, 1]) * PI / 2
                let a = cell.a + da

                x += cos(a) * r
                y += sin(a) * r
            }
            if (pts.length) {
                lines.push(pts)
                pts.map(({x, y, r}) => {
                    tree.insert(x, y, r)
                })
            }
        }

    }


</script>
</body>
</html>