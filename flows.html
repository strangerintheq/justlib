<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body style="overflow: hidden; margin: 0">
<script src="palettes.js"></script>
<script src="lib.js"></script>
<script>
    let pal = pick(Object.values(palettes));
    palette(pal)
    createCanvas2d(0.75)
    appendCanvas()
    let ctx = state.last;
    let sc = pick([0.8])
    ctx.scale(sc, sc)
    fillStyle(0)
    fillRect(-2, -2, 4, 4)
    strokeWidth(0.001)

    let seed = rnd(9999)
    const tree = q3(0, 0, 0.45, 0.45 / 0.75)
    let pad = pick([0.01, 0.1, 0.05])

    let z = 0;
    part(0.004, pal[rndi(4) + 1])
    z = 1
    part(0.01, pal[rndi(4) + 1])

    function check(x, y, r, maxR) {
        let n = noise(22 * x, 22 * y, seed)
        if (z === 0 && n > 0)
            return true
        if (z === 1 && n < 0)
            return true
        const candidates =
            tree.circle(x, y, maxR + r);
        return candidates.find(p => {
            return Math.hypot(p.x - x, p.y - y) < p.r + r + pad
        })
    }

    function brush(r, color) {
        function randomizeLightness(hsl) {
            hsl[2] = clamp(hsl[2] + rnds(.3), 0.1, 0.9)
        }

        const n = sqrt(PI * Math.pow(ctx.canvas.width * r, 2));
        const strokes = many(n, () => {
            let dr = rnd(r), a = rndr();
            let cx = cos(a) * dr, cy = sin(a) * dr;
            return {x: cx, y: cy}
        });
        return (pts) => {
            strokes.forEach(stroke => {
                strokeStyle(hslOperation(color, randomizeLightness));
                ctx.beginPath()
                pts.forEach((pt, i) => {
                    let x = stroke.x + pt.x;
                    let y = stroke.y + pt.y;
                    i ? ctx.lineTo(x, y) : ctx.moveTo(x, y);
                })
                ctx.stroke()
            })
        }
    }

    function part(maxR, color) {
        const centers = many(3, () => [rnds(), rnds()])
        const ffs = 333
        const ff = many(ffs, y => many(ffs, x => {
            let a = noise(seed + 5 * x / ffs, 5 * y / ffs, seed) +
                centers.map(p => 1 + Math.atan2(p[1] - y / ffs + 0.5, p[0] - x / ffs + 0.5)).reduce((a, b) => a + b, 0)
            //console.log(a)
            return {a}
        }))


        function getFf(x, y) {

            x += 0.5
            y += 0.5
            x *= ffs
            y *= ffs * 0.75
            try {
                return ff[y | 0][x | 0]
            } catch (e) {
            }

        }


        const lines = []
        const chance = pick([0.9, 0.99, 1])
        many(9999, () => {
            let pts = []
            let x = rnds()
            let y = rnds(1 / 0.75)
            let da = 0;
            let r = rnd(maxR * 0.9, maxR * 0.1)
            let i = 0
            while (i++ < 33 && !check(x, y, r, maxR)) {
                pts.push({x, y, r})
                let cell = getFf(x, y)
                if (!cell)
                    break
                if (rndb(chance))
                    da += pick([-1, 1]) * Math.PI / 2
                let a = cell.a + da
                x += cos(a) * r
                y += sin(a) * r
            }
            if (pts.length) {
                lines.push(pts)
                pts.map(({x, y, r}) => {
                    tree.insert(x, y, r)
                })
            }
        })

        lines.forEach(line => {
            brush(line[0].r, color)(line)
        })

    }


</script>
</body>
</html>